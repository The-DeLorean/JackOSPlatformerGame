// This file is part of JackOSPlatformerGame
// by Dorian Quimby
/**
 *  A child class of GameObject, which contains the functionality of a Player
 *  Players can move, collect KeyBlocks, die when the touch spikeblocks, and reach the VictoryBlock
 */
class Player {
    field int livesRemaining; //keeps track of deaths, will work with spikeblock
    static int speed; //
    field boolean win;
    field boolean death;
    field boolean key, dir;
    field int xpos, ypos, prevXPos, prevYPos;
    field int gravityLoop, jumpLoop, number, tick, jump;

    constructor Player new(int xin, int yin) {
        //Compose a child member data into parent game object
        let xpos = xin;
        let ypos = yin;
        let speed = 5;
        //Intailizing loop variables
        let gravityLoop = 0;
        let jumpLoop = 0; 
        let number = 0; 
        let tick = 0;
        let jump = 0;
        return this;
    }

    //Accessor and setter for gravity variable
    method int getGravity(){
        return gravityLoop;
    }
    method void setGravity(int gIn){
        let gravityLoop = gIn;
        return;
    }

    //Accessor and setter for jump variable
    method int getJump(){
        return jump;
    }
    method void setJump(int jIn){
        let jump = jIn;
        return;
    }

    //Accessor and setter for jumpLoop variable
    method int getJumpLoop(){
        return jumpLoop;
    }
    method void setJumpLoop(int jLIn){
        let jumpLoop = jLIn;
        return;
    }

    //Accessor and setter for number variable
    method int getNumber(){
        return number;
    }
    method void setNumber(int nIn){
        let number = nIn;
        return;
    }

    //Accessor and setter for tick variable
    method int getTick(){
        return tick;
    }
    method void setTick(int tIn){
        let tick = tIn;
        return;
    }

    //Accessor and settet for direction variable
    method boolean getDir(){
        return dir;
    }

     method void setDir(boolean dIn){
        let dir = dIn;
        return;
    }

    // Players can move with improved collision handling
    method void move(int dx, int dy, GameMap map, int playerNumber) {
        var boolean check;
        
        // Store previous position
        let prevXPos = xpos;
        let prevYPos = ypos;
        
        // First move horizontally and check collision
        let xpos = xpos + dx;
        let check = collides(map);
        if(check = true) {
            // Restore previous x position if collision detected
            let xpos = prevXPos;
        }
        
        // Then move vertically and check collision
        let ypos = ypos + dy;
        let check = collides(map);
        if(check = true) {
            // Restore previous y position if collision detected
            let ypos = prevYPos;
        }
        
        // Draw player at new position
        do draw(playerNumber);
        /**
        //***********************DRAWING PLAYER LOGIC OUTSIDE OF FUNCTION CALL*****************
        do Screen.setColor(false);
        do Screen.drawRectangle(prevXPos, prevYPos, prevXPos + 7, prevYPos + 7);
        do Screen.setColor(true);
        do Screen.drawRectangle(xpos, ypos, xpos + 7, ypos + 7);
        do Screen.setColor(false);
        do Screen.drawRectangle(xpos+1, ypos+5, xpos + 6, ypos + 6);
        do Screen.drawPixel(xpos + 2, ypos + 1);
        do Screen.drawPixel(xpos + 5, ypos + 1);
        **********************END OF DRAWING PLAYER LOGIC ****************************************
        */
        return;
    }

    // Renders the player
    method void draw(int playerNum) {
        do Screen.setColor(false);
        do Screen.drawRectangle(prevXPos, prevYPos, prevXPos + 7, prevYPos + 7);
        do Screen.setColor(true);
        do Screen.drawRectangle(xpos, ypos, xpos + 7, ypos + 7);
        if(playerNum = 1){
            //SAD FACE
            do Screen.setColor(false);
            //mouth curve left
            do Screen.drawPixel(xpos + 2, ypos + 5);
            do Screen.drawPixel(xpos + 1, ypos + 6);
            //Long bar
            do Screen.drawRectangle(xpos+3, ypos+4, xpos + 4, ypos + 4);
            //mouth curve right
            do Screen.drawPixel(xpos + 5, ypos + 5);
            do Screen.drawPixel(xpos + 6, ypos + 6);
            //Eyes
            do Screen.drawPixel(xpos + 2, ypos + 2);
            do Screen.drawPixel(xpos + 5, ypos + 2);
        }
        else{
            //HAPPY FACE
            do Screen.setColor(false);
            //mouth curve left
            do Screen.drawPixel(xpos + 2, ypos + 5);
            do Screen.drawPixel(xpos + 1, ypos + 4);
            //Long bar
            do Screen.drawRectangle(xpos+3, ypos+6, xpos + 4, ypos + 6);
            //mouth curve right
            do Screen.drawPixel(xpos + 5, ypos + 5);
            do Screen.drawPixel(xpos + 6, ypos + 4);
            //Eyes
            do Screen.drawPixel(xpos + 2, ypos + 2);
            do Screen.drawPixel(xpos + 5, ypos + 2);
        }
        return;
    }

    //method to check if the player is on the ground
    method boolean isOnGround(GameMap map){
        var boolean check;
        var int originalY;
        
        // Save original position
        let originalY = ypos;
        
        // Check one pixel below the player's feet
        let ypos = ypos + 1;
        let check = collides(map);
        
        // Restore original position
        let ypos = originalY;
        
        return check;
    }

    //Checking to see if the player hits the ceiling
    method boolean hitsCieling(GameMap map){
        var boolean check;
        var int originalY;
        
        // Save original position
        let originalY = ypos;
        
        // Check one pixel above the player's head
        let ypos = ypos - 1;
        let check = collides(map);
        
        // Restore original position
        let ypos = originalY;
        
        return check;
    }

    // Check for collisions using block-based approach
    //this method calculate the four corners of the player and checks to see if there is a tile at that location
    method boolean collides(GameMap map) {
        var int blockRow, blockCol; //used to store the row and column of the block that we are checking the player against
        var int gameObj;     //gameobject that is used as the comparison value against which player is checked
        var String objType;         //if there is a tile or spike, collide -- if null then let player pass
        
        // Calculate the blocks that the player is currently occupying
        // Check each corner of the player's 8x8 hitbox
        
        // Top-left corner
        let blockRow = ypos/8;
        let blockCol = xpos/8;

        //get the tile at that blockRow and block col -- getTileAtBlock returns the gameobject
        let gameObj = map.getTileAtBlock(blockRow, blockCol);
        //if there is a wall or a spike, collide with the player
        if (~(gameObj = null)) {
            //if it is a spike, kill the player
            if (gameObj = 2 | gameObj = 3) {
                let death = true;
            }
            //if it is a win, set win to true
            if (gameObj = 4) {
                let win = true;
            }
            if (gameObj = 5) {
                let key = true;
            }
            return true;
        }
        
        // Top-right corner
        let blockRow = ypos/8;
        let blockCol = (xpos + 7)/8;
        //get the tile at that blockRow and block col -- getTileAtBlock returns the gameobject
        let gameObj = map.getTileAtBlock(blockRow, blockCol);
        //if there is a wall or a spike, collide with the player
        if (~(gameObj = null)) {
            //if it is a spike, kill the player
            if (gameObj = 2 | gameObj = 3) {
                let death = true;
            }
            //if it is a win, set win to true
            if (gameObj = 4) {
                let win = true;
            }
            if (gameObj = 5) {
                let key = true;
            }
            return true;
        }
        
        // Bottom-left corner
        let blockRow = (ypos + 7)/8;
        let blockCol = xpos/8;
        //get the tile at that blockRow and block col -- getTileAtBlock returns the gameobject
        let gameObj = map.getTileAtBlock(blockRow, blockCol);
        //if there is a wall or a spike, collide with the player
        if (~(gameObj = null)) {
            //if it is a spike, kill the player
            if (gameObj = 2| gameObj = 3) {
                let death = true;
            }
            //if it is a win, set win to true
            if (gameObj = 4) {
                let win = true;
            }
            if (gameObj = 5) {
                let key = true;
            }
            return true;
        }
        
        // Bottom-right corner
        let blockRow = (ypos + 7)/ 8;
        let blockCol = (xpos + 7)/8;
        //get the tile at that blockRow and block col -- getTileAtBlock returns the gameobject
        let gameObj = map.getTileAtBlock(blockRow, blockCol);
        //if there is a wall or a spike, collide with the player
        if (~(gameObj = null)) {
            //if it is a spike, kill the player
            if (gameObj = 2| gameObj = 3) {
                let death = true;
            }
            //if it is a win, set win to true
            if (gameObj = 4) {
                let win = true;
            }
            if (gameObj = 5) {
                let key = true;
            }
            return true;
        }
        
        // No collision detected
        return false;
    }

    //Accessor for the win boolean variable
    method boolean won() {
        return win;
    }
    
    //Accessor for the death boolean variable
    method boolean died() {
        return death;
    }
    
    //Accessor for the key boolean variable
    method boolean hasKey() {
        return key;
    }

    //a method to create a new life
    method void newLife() {
        let death = false;
        return;
    }

    method String instanceof() {
        return "Player";
    }
}
